generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  USER
}

enum DraftStatus {
  PENDING
  APPROVED
  REJECTED
  POSTED
}

enum IndexStatus {
  NONE
  INDEXING
  READY
  FAILED
}

model User {
  id             String        @id @default(cuid())
  email          String        @unique
  role           UserRole      @default(USER)
  allowed        Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  drafts         Draft[]       @relation("DraftAuthor")
  approvedDrafts Draft[]       @relation("DraftApprover")
  tokens         OAuthToken[]
}

model Product {
  id            String          @id @default(cuid())
  name          String
  affiliateUrl  String
  tags          String[]        @default([])
  price         Float?
  commission    Float?
  productLink   String?
  shopeeProductId String?       @unique
  shortURL      String?
  categoryName  String?
  // Link to ShopeeCategory by its unique categoryId (Int)
  shopeeCategoryId Int?
  shopeeCategory   ShopeeCategory? @relation(fields: [shopeeCategoryId], references: [categoryId])
  brand         String?         // Brand name extracted from tags
  inStock       Boolean         @default(true)
  hasAffiliate  Boolean         @default(true)
  priceMin      Float?          // Price range for filtering (Â±10%)
  priceMax      Float?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  drafts        DraftProduct[]

  @@index([brand])
  @@index([categoryName])
  @@index([shopeeCategoryId])
  @@index([inStock, hasAffiliate])
}

model ShopeeCategory {
  id            String   @id @default(cuid())
  categoryId    Int      @unique
  name          String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  products      Product[]
}

model Comment {
  id                   String    @id @default(cuid())
  commentId            String    @unique
  textOriginal         String
  updatedAt            DateTime
  authorDisplayName    String
  authorProfileImageUrl String?
  authorChannelId      String?
  videoId              String
  canReply             Boolean
  totalReplyCount      Int
  publishedAt          DateTime
  createdAt            DateTime  @default(now())
  draft                Draft?
}

model Draft {
  id                String         @id @default(cuid())
  commentId         String         @unique
  comment           Comment        @relation(fields: [commentId], references: [id])
  reply             String
  status            DraftStatus    @default(PENDING)
  suggestedProducts Json?
  engagementScore   Float?
  relevanceScore    Float?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  createdById       String?
  createdBy         User?          @relation("DraftAuthor", fields: [createdById], references: [id])
  approvedById      String?
  approvedBy        User?          @relation("DraftApprover", fields: [approvedById], references: [id])
  approvedAt        DateTime?
  postedAt          DateTime?
  products          DraftProduct[]
}

model DraftProduct {
  draftId   String
  productId String
  createdAt DateTime @default(now())

  draft   Draft   @relation(fields: [draftId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  @@id([draftId, productId])
}

model OAuthToken {
  id           String   @id @default(cuid())
  userId       String
  provider     String
  accessToken  String
  refreshToken String?
  scope        String?
  expiresAt    DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@unique([userId, provider], name: "userId_provider")
}

model AppSetting {
  id          String   @id @default(cuid())
  channelId   String
  syncDays    Int      @default(14)
  maxSyncDays Int      @default(30)
  aiTranscriptFallback Boolean @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model VideoIndex {
  id           String      @id @default(cuid())
  videoId      String      @unique
  title        String
  status       IndexStatus @default(NONE)
  tags         String[]    @default([])
  chunksJSON   String?
  summaryJSON  String?
  source       String?
  errorMessage String?
  publishedAt  DateTime?
  categoryTags String[]    @default([])  // Categories mentioned in video
  brandTags    String[]    @default([])  // Brands mentioned in video
  priceRangeMin Float?                   // Min price mentioned
  priceRangeMax Float?                   // Max price mentioned
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  @@index([status, updatedAt])
}

// VideoProductPool: Precomputed product pools for fast retrieval
model VideoProductPool {
  id               String   @id @default(cuid())
  videoId          String
  productId        String   // Internal product ID
  relevanceScore   Float    // Metadata match score (0-1)
  matchedBrand     Boolean  @default(false)
  matchedCategory  Boolean  @default(false)
  matchedPriceRange Boolean @default(false)
  computedAt       DateTime @default(now())

  @@unique([videoId, productId])
  @@index([videoId, relevanceScore])
  @@index([productId])
}

// RAG Models
model RagDocument {
  id          Int         @id @default(autoincrement())
  sourceType  String      // comment | transcript | product
  sourceId    String
  meta        Json
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  chunks      RagChunk[]

  @@index([sourceType, sourceId])
}

model RagChunk {
  id          Int                      @id @default(autoincrement())
  docId       Int
  chunkIndex  Int
  text        String
  meta        Json
  embedding   Unsupported("vector(1536)")?
  createdAt   DateTime                 @default(now())
  document    RagDocument              @relation(fields: [docId], references: [id], onDelete: Cascade)

  @@index([docId, chunkIndex])
}
